import * as semver from "semver";
import * as inquirer from "inquirer";
import * as path from "path";
import { directoryExists } from "../utils/fs";
import { ProductionInstallation } from "../utils/installation";
import { getServicesFromInstall } from "../install/prompt";
import { yellowInstallCommand } from ".";
import { NpmPackage } from "../utils/npm";
import { corePackage } from "../nodecgIOVersions";

export interface GenerationOptions {
    bundleName: string;
    bundleDir: string;
    description: string;
    version: semver.SemVer;
    services: string[];

    // These are not from the prompt but generated by using a install info in updateGenOptsPackages
    servicePackages?: NpmPackage[];
    corePackage?: NpmPackage;
}

const kebabCaseRegex = /^([a-z][a-z0-9]*)(-[a-z0-9]+)*$/;

export async function promptGenerationOpts(
    nodecgDir: string,
    install: ProductionInstallation,
): Promise<GenerationOptions> {
    const defaultBundleDir = path.join(nodecgDir, "bundles");
    // if we are already in a bundle directory we use the name of the directory as a bundle name and the corresponding bundle dir
    const inBundleDir = path.dirname(process.cwd()) === defaultBundleDir;
    const bundleName = inBundleDir ? path.basename(process.cwd()) : undefined;
    const bundleDir = inBundleDir ? path.dirname(process.cwd()) : defaultBundleDir;

    const opts = await inquirer.prompt([
        {
            type: "input",
            name: "bundleName",
            message: "How should your new bundle be named?",
            default: bundleName,
            validate: validateBundleName,
        },
        {
            type: "input",
            name: "bundleDir",
            message: "In which bundle directory should your bundle be located?",
            default: bundleDir,
            validate: validateBundleDir,
        },
        {
            type: "input",
            name: "description",
            message: "Please give a bundle description:",
        },
        {
            type: "input",
            name: "version",
            message: "With which version number do you want to start?",
            default: "0.1.0",
            validate: validateVersion,
            filter: (ver) => new semver.SemVer(ver),
        },
        {
            type: "checkbox",
            name: "services",
            message: `Which services would you like to use? (they must be installed through ${yellowInstallCommand} first)`,
            choices: getServicesFromInstall(install, install.version),
            validate: validateServiceSelection,
        },
        // TODO: license
        // TODO: dashboard
        // TODO: graphic
        // TODO: language js/ts
    ]);

    updateGenOptsPackages(opts, install);
    return opts;
}

function validateBundleName(str: string): true | string {
    if (str.length === 0) {
        return "You must provide a bundle name.";
    } else if (kebabCaseRegex.exec(str) === null) {
        return "Your bundle name should be in kebab case. E.g. my-nodecg-bundle-name.";
    } else {
        return true;
    }
}

async function validateBundleDir(dir: string): Promise<true | string> {
    if (await directoryExists(dir)) {
        return true;
    } else {
        return "The directory does not exist.";
    }
}

function validateVersion(ver: string): true | string {
    try {
        new semver.SemVer(ver);
        return true;
    } catch (_e) {
        return "Please enter a valid version number.";
    }
}

function validateServiceSelection(services: string[]): true | string {
    if (services.length === 0) {
        return "You should select at least one service to use.";
    } else {
        return true;
    }
}

function updateGenOptsPackages(opts: GenerationOptions, install: ProductionInstallation) {
    opts.corePackage = install.packages.find((pkg) => pkg.name === corePackage);
    opts.servicePackages = opts.services.map((svc) => {
        const svcPackage = install.packages.find((pkg) => pkg.name.endsWith(svc));

        if (svcPackage === undefined) {
            throw new Error(`Service ${svc} has no corresponding package in the passed installation.`);
        }
        return svcPackage;
    });
}
